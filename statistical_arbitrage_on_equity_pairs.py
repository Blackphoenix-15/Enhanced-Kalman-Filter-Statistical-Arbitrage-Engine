# -*- coding: utf-8 -*-
"""Statistical Arbitrage on Equity Pairs.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nDRbDzS6tF1W0kq3az7xbvQ-w8oEyD3V
"""

import yfinance as yf
import pandas as pd
import os

def load_data(tickers, start='2020-01-01', end='2024-12-31'):
    df = yf.download(tickers, start=start, end=end)
    return df.dropna()

if __name__ == "__main__":
    tickers = ['V', 'MA']
    df = load_data(tickers)
    os.makedirs('data/raw', exist_ok=True)
    df.to_csv('data/raw/v_ma.csv')

import pandas as pd

df = pd.read_csv('data/raw/ko_pep.csv', index_col=0)
print("Columns in your CSV:")
print(df.columns)

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import coint

def load_pair_data(path='data/raw/v_ma.csv'):
    """
    Loads V and MA close price data from CSV.
    Assumes 'Close' = MA, 'Close.1' = V based on yfinance format.
    """
    df = pd.read_csv(path, index_col=0, parse_dates=True, skiprows=[1])
    df = df.dropna()

    s1 = df['Close']
    s2 = df['Close.1']

    return s1, s2

def test_cointegration(s1, s2):
    """
    Returns True if p-value < 0.05 indicating cointegration.
    """
    score, pvalue, _ = coint(s1, s2)
    print(f"Cointegration test p-value: {pvalue:.5f}")
    return pvalue < 0.05

def get_spread(s1, s2):
    """
    Computes spread using static hedge ratio (mean of s1/s2).
    """

    s1 = pd.to_numeric(s1)
    s2 = pd.to_numeric(s2)
    hedge_ratio = (s1 / s2).mean()
    spread = s1 - hedge_ratio * s2
    return spread, hedge_ratio

def zscore(series):
    """
    Returns z-score of a given series.
    """

    series = pd.to_numeric(series)
    return (series - series.mean()) / series.std()

def plot_zscore(z):
    """
    Plots z-score with threshold lines.
    """
    plt.figure(figsize=(14, 6))
    plt.plot(z, label='Z-Score of Spread')
    plt.axhline(1.0, color='red', linestyle='--', label='Sell Threshold')
    plt.axhline(-1.0, color='green', linestyle='--', label='Buy Threshold')
    plt.axhline(0.0, color='black', linestyle='-', label='Mean Reversion')
    plt.title("Z-Score of Spread: MA vs V")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    s1, s2 = load_pair_data()

    if test_cointegration(s1, s2):
        spread, hedge_ratio = get_spread(s1, s2)
        z = zscore(spread)
        print(f"Hedge ratio: {hedge_ratio:.4f}")
        plot_zscore(z)
    else:
        print("MA and V are not cointegrated — choose another pair.")

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

def generate_signals(z, entry_threshold=1.0, exit_threshold=0.0):
    signals = pd.DataFrame(index=z.index)
    signals['long'] = (z < -entry_threshold).astype(int)
    signals['short'] = (z > entry_threshold).astype(int)
    signals['exit'] = (abs(z) < exit_threshold).astype(int)

    position = 0
    positions = []

    for i in range(len(z)):
        if signals['long'].iloc[i]:
            position = 1
        elif signals['short'].iloc[i]:
            position = -1
        elif signals['exit'].iloc[i]:
            position = 0
        positions.append(position)

    signals['position'] = positions
    return signals

def backtest(s1, s2, hedge_ratio, signals):
    pnl = pd.DataFrame(index=s1.index)
    pnl['spread'] = s1 - hedge_ratio * s2
    pnl['position'] = signals['position']
    pnl['spread_change'] = pnl['spread'].diff()
    pnl['pnl'] = pnl['position'].shift() * pnl['spread_change']
    pnl['cum_pnl'] = pnl['pnl'].cumsum()
    return pnl

def plot_pnl(pnl):
    plt.figure(figsize=(14, 6))
    plt.plot(pnl['cum_pnl'], label='Cumulative PnL')
    plt.title("Cumulative PnL from Pairs Trading Strategy")
    plt.xlabel("Date")
    plt.ylabel("PnL")
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.show()

# !pip install strategy_backtest # This library does not exist
# from strategy_backtest import generate_signals, backtest, plot_pnl # Remove this import as functions are defined elsewhere

signals = generate_signals(z)
pnl = backtest(s1, s2, hedge_ratio, signals)
plot_pnl(pnl)

def performance_metrics(pnl):
    returns = pnl['pnl'].fillna(0)
    sharpe = np.sqrt(252) * returns.mean() / returns.std()
    drawdown = (pnl['cum_pnl'] - pnl['cum_pnl'].cummax()).min()

    print(f"Sharpe Ratio: {sharpe:.2f}")
    print(f"Max Drawdown: {drawdown:.2f}")

performance_metrics(pnl)

!pip install pykalman

import numpy as np
import pandas as pd
from pykalman import KalmanFilter
import matplotlib.pyplot as plt

def kalman_estimate(y, x):
    delta = 1e-5  # process noise
    trans_cov = delta / (1 - delta) * np.eye(2)  # state transition covariance
    obs_mat = np.expand_dims(np.vstack([x, np.ones(len(x))]).T, axis=1)

    kf = KalmanFilter(
        n_dim_obs=1,
        n_dim_state=2,
        initial_state_mean=[0, 0],
        initial_state_covariance=np.ones((2, 2)),
        transition_matrices=np.eye(2),
        observation_matrices=obs_mat,
        observation_covariance=1.0,
        transition_covariance=trans_cov
    )

    state_means, _ = kf.filter(y.values)
    hedge_ratio = state_means[:, 0]
    intercept = state_means[:, 1]

    return hedge_ratio, intercept

hedge_ratio, intercept = kalman_estimate(s1, s2)

# Calculate dynamic spread
spread = s1 - hedge_ratio * s2 - intercept

# Get z-score of spread
rolling_mean = pd.Series(spread).rolling(window=30).mean()
rolling_std = pd.Series(spread).rolling(window=30).std()
z_score = (spread - rolling_mean) / rolling_std

plt.figure(figsize=(12, 4))
plt.plot(hedge_ratio, label='Dynamic Hedge Ratio')
plt.title("Kalman Filter Estimated Hedge Ratio (Time-varying)")
plt.legend()
plt.grid(True)
plt.show()

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from pykalman import KalmanFilter

# Step 1: Download historical price data
def load_price_data(tickers, start='2020-01-01', end='2024-12-31'):
    df = yf.download(tickers, start=start, end=end) # Return the full DataFrame
    return df.dropna()

# Step 2: Estimate dynamic hedge ratio using Kalman Filter
def kalman_filter_estimation(x, y):
    delta = 1e-5
    trans_cov = delta / (1 - delta) * np.eye(2)
    obs_mat = np.expand_dims(np.vstack([x, np.ones(len(x))]).T, axis=1)

    kf = KalmanFilter(
        n_dim_obs=1,
        n_dim_state=2,
        initial_state_mean=[0, 0],
        initial_state_covariance=np.ones((2, 2)),
        transition_matrices=np.eye(2),
        observation_matrices=obs_mat,
        observation_covariance=1.0,
        transition_covariance=trans_cov,
    )
    # Ensure y data is in the correct shape and type
    y_values = y.values.astype(np.float64).reshape(-1, 1)
    state_means, _ = kf.filter(y_values)
    hedge_ratios = pd.Series(state_means[:, 0], index=y.index)
    intercepts = pd.Series(state_means[:, 1], index=y.index)
    return hedge_ratios, intercepts

# Step 3: Compute spread and Z-score
def compute_kalman_spread(x, y, hedge_ratios, intercepts):
    spread = y - (hedge_ratios * x + intercepts)
    zscore = (spread - spread.rolling(20).mean()) / spread.rolling(20).std()
    return spread, zscore

# Step 4: Trading logic based on Z-score
def generate_kalman_signals(zscore, entry_threshold=2, exit_threshold=0.5):
    position = pd.Series(0, index=zscore.index)
    in_trade = False
    for i in range(1, len(zscore)):
        if not in_trade:
            if zscore[i] > entry_threshold:
                position[i] = -1
                in_trade = True
            elif zscore[i] < -entry_threshold:
                position[i] = 1
                in_trade = True
        else:
            if abs(zscore[i]) < exit_threshold:
                position[i] = 0
                in_trade = False
            else:
                position[i] = position[i-1]
    return position.ffill().fillna(0)

# Step 5: Compute PnL
def compute_pnl(x, y, position, hedge_ratios):
    spread = y - hedge_ratios * x
    pnl = position.shift(1) * spread.diff()
    cum_pnl = pnl.cumsum()
    return pd.DataFrame({'pnl': pnl, 'cum_pnl': cum_pnl})

# Step 6: Performance reporting
def performance_metrics(pnl_df):
    returns = pnl_df['pnl'].dropna()
    sharpe = np.sqrt(252) * returns.mean() / returns.std() if returns.std() else np.nan
    drawdown = (pnl_df['cum_pnl'] - pnl_df['cum_pnl'].cummax()).min()
    print(f"Sharpe Ratio: {sharpe:.2f}")
    print(f"Max Drawdown: {drawdown:.2f}")

# Step 7: Pipeline execution
def run_kalman_strategy(ticker_x, ticker_y):
    df = load_price_data([ticker_x, ticker_y])

    x, y = df[('Close', ticker_x)], df[('Close', ticker_y)]


    x = x.astype(np.float64)
    y = y.astype(np.float64)


    hedge_ratios, intercepts = kalman_filter_estimation(x, y)
    spread, zscore = compute_kalman_spread(x, y, hedge_ratios, intercepts)
    position = generate_kalman_signals(zscore)
    pnl_df = compute_pnl(x, y, position, hedge_ratios)

    performance_metrics(pnl_df)

    # Plotting
    plt.figure(figsize=(14, 5))
    plt.plot(pnl_df['cum_pnl'], label='Cumulative PnL')
    plt.title(f'Cumulative PnL: {ticker_x} vs {ticker_y}')
    plt.legend()
    plt.grid()
    plt.show()

    plt.figure(figsize=(14, 4))
    plt.plot(hedge_ratios, label='Dynamic Hedge Ratio')
    plt.title('Kalman Filter Estimated Hedge Ratio')
    plt.legend()
    plt.grid()
    plt.show()

# Example Run
run_kalman_strategy("MA", "V")

# ✅ Enhanced Kalman Filter Pairs Trading Engine

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from pykalman import KalmanFilter
import os

# Parameters
ENTRY_Z = 2
EXIT_Z = 0.5
VOL_LOOKBACK = 20
RISK_PER_TRADE = 0.01  # 1% of capital
SLIPPAGE_PCT = 0.001  # 0.1% slippage
STARTING_CAPITAL = 100000

# Load flat-structure CSV (Close, Close.1)
def load_data(path):
    df = pd.read_csv(path, index_col=0, parse_dates=True, skiprows=[1]) # Skip the first row
    df = df[['Close', 'Close.1']].dropna()
    df.columns = ['X', 'Y']
    return df

# Kalman Filter estimation
def kalman_filter(x, y):
    delta = 1e-5
    trans_cov = delta / (1 - delta) * np.eye(2)
    obs_mat = np.expand_dims(np.vstack([x, np.ones(len(x))]).T, axis=1)

    kf = KalmanFilter(
        n_dim_obs=1,
        n_dim_state=2,
        initial_state_mean=[0, 0],
        initial_state_covariance=np.ones((2, 2)),
        transition_matrices=np.eye(2),
        observation_matrices=obs_mat,
        observation_covariance=1.0,
        transition_covariance=trans_cov,
    )
    # Ensure y data is in the correct shape and type for the filter
    y_values = y.values.astype(np.float64).reshape(-1, 1)
    state_means, _ = kf.filter(y_values)
    hedge_ratios = pd.Series(state_means[:, 0], index=y.index)
    intercepts = pd.Series(state_means[:, 1], index=y.index)
    return hedge_ratios, intercepts

# Spread and z-score with volatility scaling
def compute_spread_z(x, y, hedge_ratios, intercepts):
    spread = y - (hedge_ratios * x + intercepts)
    rolling_std = spread.rolling(VOL_LOOKBACK).std()
    zscore = (spread - spread.rolling(VOL_LOOKBACK).mean()) / rolling_std
    volatility = rolling_std / spread.rolling(VOL_LOOKBACK).mean().abs()
    return spread, zscore, volatility

# Signal generation with dynamic thresholds
def generate_signals(zscore, volatility):
    position = pd.Series(0, index=zscore.index)
    in_trade = False
    for i in range(1, len(zscore)):
        entry_th = ENTRY_Z * volatility.iloc[i] if not np.isnan(volatility.iloc[i]) else ENTRY_Z
        exit_th = EXIT_Z * volatility.iloc[i] if not np.isnan(volatility.iloc[i]) else EXIT_Z

        if not in_trade:
            if zscore.iloc[i] > entry_th:
                position.iloc[i] = -1
                in_trade = True
            elif zscore.iloc[i] < -entry_th:
                position.iloc[i] = 1
                in_trade = True
        else:
            if abs(zscore.iloc[i]) < exit_th:
                position.iloc[i] = 0
                in_trade = False
            else:
                position.iloc[i] = position.iloc[i-1]
    return position.ffill().fillna(0)

# Position sizing + PnL + slippage
def compute_pnl(df, position, hedge_ratios):
    x, y = df['X'], df['Y']
    capital = STARTING_CAPITAL
    # Ensure size calculation uses numeric data
    size = (capital * RISK_PER_TRADE) / x.astype(np.float64)
    spread = y - hedge_ratios * x
    pnl = position.shift(1) * spread.diff() - SLIPPAGE_PCT * abs(position.diff())
    cum_pnl = pnl.cumsum()
    return pd.DataFrame({'pnl': pnl, 'cum_pnl': cum_pnl})

# Performance reporting
def performance_metrics(pnl_df):
    returns = pnl_df['pnl'].dropna()
    sharpe = np.sqrt(252) * returns.mean() / returns.std() if returns.std() else np.nan
    drawdown = (pnl_df['cum_pnl'] - pnl_df['cum_pnl'].cummax()).min()
    print(f"Sharpe Ratio: {sharpe:.2f}\nMax Drawdown: {drawdown:.2f}")

# Strategy runner
def run_kalman_strategy(csv_path):
    df = load_data(csv_path)
    # Ensure data is float64 and y is reshaped before passing to kalman_filter
    x_data = df['X'].astype(np.float64)
    y_data = df['Y'].astype(np.float64)

    hedge_ratios, intercepts = kalman_filter(x_data, y_data)
    spread, zscore, volatility = compute_spread_z(df['X'], df['Y'], hedge_ratios, intercepts)
    position = generate_signals(zscore, volatility)
    pnl_df = compute_pnl(df, position, hedge_ratios)
    performance_metrics(pnl_df)

    plt.figure(figsize=(14, 5))
    plt.plot(pnl_df['cum_pnl'], label='Cumulative PnL')
    plt.legend(); plt.grid(); plt.title("Strategy Performance")
    plt.show()

    plt.figure(figsize=(14, 4))
    plt.plot(hedge_ratios, label='Hedge Ratio')
    plt.legend(); plt.grid(); plt.title("Dynamic Hedge Ratio")
    plt.show()

# Example usage (update with your CSV path)
# run_kalman_strategy("data/raw/ko_pep.csv")

# ---------------------- 🔍 Example Usage ----------------------

if __name__ == "__main__":
    # Replace with any local CSV containing columns: Close, Close.1
    path_to_data = "data/raw/ko_pep.csv"  # 👈 Update if needed
    if os.path.exists(path_to_data):
        print(f"✅ Running Kalman Filter strategy on: {path_to_data}")
        run_kalman_strategy(path_to_data)
    else:
        print(f"⚠️ CSV not found at {path_to_data}. Please provide a valid path.")